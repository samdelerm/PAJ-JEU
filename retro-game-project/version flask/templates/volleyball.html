{% extends 'base.html' %}
{% block title %}Beach Volleyball - Les jeux du PAJ{% endblock %}
{% block content %}
<style>
    #game-container { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 70vh; width: 100vw; box-sizing: border-box; }
    #volley-canvas { background: #87CEEB; border-radius: 16px; box-shadow: 0 0 30px #000; display: block; width: 100vw; max-width: 900px; height: auto; aspect-ratio: 4/3; max-height: 70vw; min-height: 220px; margin: 0 auto; touch-action: none; }
    #touch-controls { position: fixed; left: 0; right: 0; bottom: 0; z-index: 10; display: flex; justify-content: center; gap: 6vw; pointer-events: none; }
    #touch-controls button { width: 18vw; min-width: 56px; max-width: 120px; height: 18vw; min-height: 56px; max-height: 120px; border-radius: 50%; background: #fff3; -webkit-backdrop-filter: blur(2px); backdrop-filter: blur(2px); border: none; font-size: 2.2em; pointer-events: auto; margin-bottom: 2vh; }
    #btn-restart {
        display: none;
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: 16vh;
        z-index: 20;
        padding: 18px 38px;
        font-size: 1.5em;
        border-radius: 18px;
        background: #fff3;
        color: #222;
        border: none;
        box-shadow: 0 2px 12px #0004;
    }
    @media (max-width: 700px) {
        #volley-canvas { max-width: 100vw; max-height: 44vh; }
        #touch-controls button { font-size: 2.7em; }
        #btn-restart { font-size: 1.2em; padding: 12px 18px; }
    }
    @media (max-width: 500px) {
        #volley-canvas { max-width: 100vw; max-height: 36vh; }
        #btn-restart { font-size: 1em; padding: 8px 10px; }
    }
    footer { margin-top: 20px; color: #fff; font-family: 'Press Start 2P',cursive,Arial,sans-serif; font-size: 1.1em; text-align: center; width: 100vw; }
</style>
<div id="game-container">
    <canvas id="volley-canvas" width="800" height="600"></canvas>
        <!-- Contrôles tactiles pour mobile -->
        <div id="touch-controls">
                <button id="btn-left">◀️</button>
                <button id="btn-jump">⏫</button>
                <button id="btn-right">▶️</button>
        </div>
    </div>
        <button id="btn-restart" style="display:none;position:fixed;left:50%;transform:translateX(-50%);bottom:16vh;z-index:20;padding:18px 38px;font-size:1.5em;border-radius:18px;background:#fff3;color:#222;border:none;box-shadow:0 2px 12px #0004;">Recommencer</button>
        <footer>
            &copy; CDC DU BAZADAIS - Tous droits réservés
        </footer>
</div>
// </script>
<script>
// Jeu de Beach Volleyball amélioré
class SimpleVolleyball {
    constructor(canvas) {
        this.aiPower = 1; // Puissance IA (1 = normal)
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setSize();
    this.ball = { x: this.width/2, y: 200, vx: 1.7, vy: -2.7, r: 18 };
    this.p1 = { x: this.width*0.15, y: this.ground, w: this.width*0.055, h: this.height*0.11, vy: 0, jumping: false, color: '#FF6B6B', score: 0 };
    this.p2 = { x: this.width*0.75, y: this.ground, w: this.width*0.055, h: this.height*0.11, vy: 0, jumping: false, color: '#4ECDC4', score: 0 };
        this.net = { x: this.width/2-20, y: 420, w: 40, h: 180 };
        this.ground = 560;
        this.keys = {};
        this.lastPoint = null; // 1 ou 2
        this.pointAnim = 0;
        this.winner = null;
        this.initControls();
        this.loop = this.loop.bind(this);
        window.addEventListener('resize', () => this.setSize());
        requestAnimationFrame(this.loop);
    }
    setSize() {
        // Ratio paysage, s'adapte à l'écran
        let w = Math.min(window.innerWidth*0.98, 900);
        let h = Math.round(w * 0.75); // 4:3 ratio
        if(window.innerHeight < h + 120) h = window.innerHeight - 80;
        if(window.innerWidth<700) { w = window.innerWidth*0.99; h = w*0.75; }
        if(window.innerWidth<500) { w = window.innerWidth*0.99; h = w*0.75; }
        this.canvas.width = w;
        this.canvas.height = h;
        this.width = w;
        this.height = h;
        // Proportions dynamiques
        this.ground = this.height * 0.88;
        this.net = { x: this.width/2-this.width*0.045, y: this.ground-this.height*0.28, w: this.width*0.09, h: this.height*0.28 };
        // Replace les joueurs et la balle si resize
        if(this.p1) {
            this.p1.y = this.ground;
            this.p1.w = this.width*0.055;
            this.p1.h = this.height*0.11;
        }
        if(this.p2) {
            this.p2.y = this.ground;
            this.p2.w = this.width*0.055;
            this.p2.h = this.height*0.11;
        }
        if(this.ball) this.ball.r = Math.max(12, this.width*0.022);
    }
    initControls() {
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
    }
    update() {
        // Ajuste la puissance IA selon l'écart de score
        let playerScore = this.p1.score;
        let aiScore = this.p2.score;
        let newAIPower = 1 + Math.floor((aiScore-playerScore)/2)*0.13 - Math.floor((playerScore-aiScore)/2)*0.13;
        this.aiPower = Math.max(0.6, Math.min(1.25, newAIPower));
        // Joueur 1 (ZQSD)
        let jumpPower = -this.height*0.025; // hauteur de saut proportionnelle
        if (this.keys['z'] && !this.p1.jumping) { this.p1.vy = jumpPower; this.p1.jumping = true; }
        let moveSpeed = this.width*0.018; // vitesse horizontale proportionnelle
        if (this.keys['q']) this.p1.x -= moveSpeed;
        if (this.keys['d']) this.p1.x += moveSpeed;
        this.p1.x = Math.max(0, Math.min(this.p1.x, this.width/2-this.p1.w));
        // Saut
        this.p1.y += this.p1.vy; this.p1.vy += this.height*0.002;
        if (this.p1.y > this.ground) { this.p1.y = this.ground; this.p1.vy = 0; this.p1.jumping = false; }
        // IA améliorée joueur 2
        if (this.ball.x > this.width/2) {
            let aiSpeed = this.width*0.009 * this.aiPower;
            if (this.ball.x > this.p2.x+this.p2.w/2) this.p2.x += aiSpeed;
            if (this.ball.x < this.p2.x+this.p2.w/2) this.p2.x -= aiSpeed;
        }
        this.p2.x = Math.max(this.width/2, Math.min(this.p2.x, this.width-this.p2.w));
        // Saut IA
        let aiJump = -this.height*0.025 * this.aiPower;
        if (!this.p2.jumping && Math.abs(this.ball.x-(this.p2.x+this.p2.w/2))<this.width*0.055 && this.ball.y<this.p2.y) {
            this.p2.vy = aiJump; this.p2.jumping = true;
        }
        this.p2.y += this.p2.vy; this.p2.vy += this.height*0.002;
        if (this.p2.y > this.ground) { this.p2.y = this.ground; this.p2.vy = 0; this.p2.jumping = false; }
        // Balle
        this.ball.x += this.ball.vx; this.ball.y += this.ball.vy; this.ball.vy += this.height*0.00037; // gravité proportionnelle
        // Limite la hauteur max de la balle
        let minBallY = this.height*0.09;
        if (this.ball.y < minBallY) {
            this.ball.y = minBallY;
            if (this.ball.vy < 0) this.ball.vy = this.height*0.0008;
        }
        // Correction disparition balle : ne rebondit que si elle touche le sol ET descend
        if (this.ball.y > this.ground-this.ball.r && this.ball.vy > 0 && !this.winner) {
            this.ball.y = this.ground-this.ball.r; this.ball.vy *= -0.7;
            // Point pour l'équipe adverse dès que la balle touche le sol
            if (this.ball.x < this.width/2) {
                this.p2.score++;
                this.lastPoint = 2;
            } else {
                this.p1.score++;
                this.lastPoint = 1;
            }
            this.pointAnim = 1.5; // secondes d'animation
            if (this.p1.score >= 10) this.winner = 1;
            if (this.p2.score >= 10) this.winner = 2;
            this.resetBall();
        }
        // Rebonds murs
        if (this.ball.x < this.ball.r || this.ball.x > this.width-this.ball.r) this.ball.vx *= -1;
        if (this.ball.y < this.ball.r) this.ball.vy *= -1;
        // Filet
        if (this.ball.x > this.net.x && this.ball.x < this.net.x+this.net.w && this.ball.y+this.ball.r > this.net.y) {
            this.ball.vx *= -1;
        }
        // Collision joueurs (toujours vers le camp adverse)
        this.checkPlayerCollision(this.p1, 1);
        this.checkPlayerCollision(this.p2, -1);
    }
    checkPlayerCollision(p, direction) {
        let dx = this.ball.x-(p.x+p.w/2), dy = this.ball.y-(p.y+p.h/2);
        let dist = Math.sqrt(dx*dx+dy*dy);
        let collisionDist = this.ball.r + this.width*0.04;
        if (dist < collisionDist && this.ball.y < p.y+p.h) {
            // Toujours vers le camp adverse, angle forcé
            let force = this.width*0.014;
            let baseAngle = direction > 0 ? Math.PI/4 : 3*Math.PI/4;
            let angle = baseAngle + (Math.random()-0.5)*Math.PI/10; // petit aléa
            this.ball.vx = Math.abs(Math.cos(angle)*force) * direction;
            this.ball.vy = -Math.abs(Math.sin(angle)*force) - this.height*0.018;
        }
    }
    resetBall() {
        // Réinitialise les positions des joueurs et de la balle pour un engagement
        this.p1.x = this.width*0.15;
        this.p1.y = this.ground;
        this.p1.vy = 0;
        this.p1.jumping = false;
        this.p2.x = this.width*0.75;
        this.p2.y = this.ground;
        this.p2.vy = 0;
        this.p2.jumping = false;
        // Engagement : la balle part du centre mais plus haut et plus "loin" pour laisser le temps à l'IA
        this.ball.x = this.width/2;
        this.ball.y = this.ground-this.height*0.38; // plus haut qu'avant (0.25)
        // Engagement : la balle part vers le joueur qui a encaissé le point, vitesse adaptée au ratio
        let dir = (this.lastPoint === 1) ? -1 : 1;
        // Vitesse horizontale et verticale proportionnelle à la taille du terrain
        this.ball.vx = dir * (this.width*0.003 + Math.random()*this.width*0.001);
        this.ball.vy = -this.height*0.012 - Math.random()*this.height*0.004;
    }
    render() {
        let ctx = this.ctx;
        ctx.clearRect(0,0,this.width,this.height);
        // Ciel dégradé + nuages
        let grad = ctx.createLinearGradient(0,0,0,this.height);
        grad.addColorStop(0,'#7ed6ff'); grad.addColorStop(1,'#ffe4b5');
        ctx.fillStyle = grad; ctx.fillRect(0,0,this.width,this.height);
        // Nuages
        for(let i=0;i<3;i++) {
            ctx.save(); ctx.globalAlpha=0.18;
            ctx.beginPath(); ctx.ellipse(200+220*i,80+30*i,60,28,0,0,2*Math.PI);
            ctx.fillStyle='#fff'; ctx.fill(); ctx.restore();
        }
        // Soleil
        ctx.save(); ctx.globalAlpha=0.18;
        ctx.beginPath(); ctx.arc(120,100,80,0,2*Math.PI);
        ctx.fillStyle='#fff59d'; ctx.fill(); ctx.restore();
        // Sable avec texture
        let sandGrad = ctx.createLinearGradient(0,this.ground+20,0,this.height);
        sandGrad.addColorStop(0,'#F4D03F'); sandGrad.addColorStop(1,'#F1C40F');
        ctx.fillStyle = sandGrad; ctx.fillRect(0,this.ground+20,this.width,80);
        for(let i=0;i<40;i++) { ctx.save(); ctx.globalAlpha=0.12+Math.random()*0.08; ctx.beginPath(); ctx.arc(Math.random()*this.width,this.ground+40+Math.random()*40,Math.random()*8+2,0,2*Math.PI); ctx.fillStyle='#fffde4'; ctx.fill(); ctx.restore(); }
        // Filet amélioré
        ctx.save();
        ctx.shadowColor = '#fff'; ctx.shadowBlur = 12;
        ctx.fillStyle = '#a67c52'; ctx.fillRect(this.net.x,this.net.y,this.net.w,this.net.h);
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5;
        for(let i=0;i<10;i++) { ctx.beginPath(); ctx.moveTo(this.net.x,this.net.y+i*18); ctx.lineTo(this.net.x+this.net.w,this.net.y+i*18); ctx.stroke(); }
        for(let i=0;i<4;i++) { ctx.beginPath(); ctx.moveTo(this.net.x+i*13,this.net.y); ctx.lineTo(this.net.x+i*13,this.net.y+this.net.h); ctx.stroke(); }
        ctx.restore();
        // Palmiers décoratifs
        this.drawPalmTree(60,320,1);
        this.drawPalmTree(this.width-100,340,0.8);
        // Joueurs
        this.drawPlayer(this.p1,1);
        this.drawPlayer(this.p2,-1);
        // Balle (effet glow)
        ctx.save(); ctx.beginPath(); ctx.arc(this.ball.x,this.ball.y,this.ball.r,0,2*Math.PI);
        let ballGrad = ctx.createRadialGradient(this.ball.x,this.ball.y,this.ball.r*0.2,this.ball.x,this.ball.y,this.ball.r);
        ballGrad.addColorStop(0,'#fffde4'); ballGrad.addColorStop(1,'#ffe66d');
        ctx.fillStyle = ballGrad; ctx.shadowColor = '#ffe66d'; ctx.shadowBlur = 18; ctx.fill(); ctx.restore();
        // Score amélioré
        ctx.save();
        ctx.font = 'bold 44px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#fff'; ctx.shadowBlur = 8;
        ctx.fillStyle = this.p1.color;
        ctx.fillText(this.p1.score, this.width/2-80, 60);
        ctx.fillStyle = this.p2.color;
        ctx.fillText(this.p2.score, this.width/2+80, 60);
        ctx.shadowBlur = 0;
        ctx.font = '20px Arial'; ctx.fillStyle = '#222';
        ctx.fillText('ZQSD ou boutons pour jouer', this.width/2, 36);
        ctx.restore();
        // Animation du dernier point
        if (this.pointAnim > 0 && this.lastPoint) {
            ctx.save();
            ctx.globalAlpha = Math.min(1, this.pointAnim);
            ctx.font = 'bold 48px Arial';
            ctx.fillStyle = this.lastPoint === 1 ? this.p1.color : this.p2.color;
            ctx.textAlign = this.lastPoint === 1 ? 'left' : 'right';
            ctx.fillText('+1', this.lastPoint === 1 ? 60 : this.width-60, 120);
            ctx.restore();
            this.pointAnim -= 1/60;
            if (this.pointAnim < 0) this.pointAnim = 0;
        }
        // Message de victoire
        if (this.winner) {
            ctx.save();
            ctx.globalAlpha = 0.92;
            ctx.fillStyle = '#fff';
            ctx.fillRect(this.width/2-220, this.height/2-80, 440, 160);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = this.winner === 1 ? this.p1.color : this.p2.color;
            ctx.lineWidth = 6;
            ctx.strokeRect(this.width/2-220, this.height/2-80, 440, 160);
            ctx.font = 'bold 44px Arial';
            ctx.fillStyle = this.winner === 1 ? this.p1.color : this.p2.color;
            ctx.textAlign = 'center';
            ctx.fillText('Victoire ' + (this.winner === 1 ? 'Joueur' : 'IA'), this.width/2, this.height/2);
            ctx.font = '24px Arial';
            ctx.fillStyle = '#222';
            ctx.fillText('Appuie sur R ou sur le bouton pour rejouer', this.width/2, this.height/2+48);
            ctx.restore();
            // Affiche le bouton tactile si sur mobile
            if (window.innerWidth < 1000 || window.innerHeight < 800) {
                document.getElementById('btn-restart').style.display = 'block';
            }
        } else {
            document.getElementById('btn-restart').style.display = 'none';
        }
    }

    // Ajout : touche R pour reset
    initControls() {
        window.addEventListener('keydown', e => {
            this.keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 'r' && this.winner) {
                this.p1.score = 0; this.p2.score = 0; this.winner = null; this.lastPoint = null; this.pointAnim = 0;
            }
        });
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
    }
    drawPlayer(p, dir) {
        let ctx = this.ctx;
        ctx.save();
    // Ombre
    ctx.globalAlpha=0.18; ctx.beginPath(); ctx.ellipse(p.x+p.w/2,p.y+p.h+18,p.w*0.7,12,0,0,2*Math.PI); ctx.fillStyle='#222'; ctx.fill(); ctx.globalAlpha=1;
    // Corps avec effet
    let grad = ctx.createLinearGradient(p.x,p.y,p.x,p.y+p.h);
    grad.addColorStop(0,p.color);
    grad.addColorStop(1,'#fff');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.ellipse(p.x+p.w/2,p.y+p.h/2,p.w/2,p.h/2,0,0,2*Math.PI); ctx.fill();
    // Tête
    ctx.beginPath(); ctx.arc(p.x+p.w/2,p.y+18,18,0,2*Math.PI); ctx.fillStyle='#ffe0b2'; ctx.fill();
    // Visage (sourire)
    ctx.beginPath(); ctx.arc(p.x+p.w/2,p.y+22,8,0,Math.PI,false); ctx.strokeStyle='#a67c52'; ctx.lineWidth=2; ctx.stroke();
    // Yeux
    ctx.beginPath(); ctx.arc(p.x+p.w/2-5,p.y+15,2,0,2*Math.PI); ctx.arc(p.x+p.w/2+5,p.y+15,2,0,2*Math.PI); ctx.fillStyle='#222'; ctx.fill();
    // Bras
    ctx.save(); ctx.translate(p.x+p.w/2,p.y+38);
    ctx.rotate(dir*0.2);
    ctx.fillStyle=p.color; ctx.fillRect(-p.w/2-8,-8,22,12);
    ctx.restore();
    ctx.save(); ctx.translate(p.x+p.w/2,p.y+38);
    ctx.rotate(-dir*0.2);
    ctx.fillStyle=p.color; ctx.fillRect(p.w/2-14,-8,22,12);
    ctx.restore();
    // Short
    ctx.fillStyle = dir>0?'#fff':'#222';
    ctx.fillRect(p.x+8,p.y+p.h-18,p.w-16,18);
    ctx.restore();
    }
    drawPalmTree(x,y,scale) {
        let ctx = this.ctx;
        ctx.save();
        ctx.translate(x,y);
        ctx.scale(scale,scale);
        // Tronc
        ctx.strokeStyle='#a67c52'; ctx.lineWidth=10;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,60); ctx.stroke();
        // Feuilles
        ctx.strokeStyle='#388e3c'; ctx.lineWidth=7;
        for(let i=0;i<5;i++) {
            ctx.beginPath(); ctx.arc(0,0,38,Math.PI*0.2*i,Math.PI*0.2*i+Math.PI*0.7);
            ctx.stroke();
        }
        ctx.restore();
    }
    loop() {
        this.update();
        this.render();
        requestAnimationFrame(this.loop);
    }
}
document.addEventListener('DOMContentLoaded', function() {
    // Bouton tactile pour recommencer
    document.getElementById('btn-restart').addEventListener('click', function() {
        game.p1.score = 0; game.p2.score = 0; game.winner = null; game.lastPoint = null; game.pointAnim = 0;
        this.style.display = 'none';
    });
    const game = new SimpleVolleyball(document.getElementById('volley-canvas'));
    // Contrôles tactiles pour mobile
    function setKey(key, pressed) {
        game.keys[key] = pressed;
    }
    document.getElementById('btn-left').addEventListener('touchstart', e => { setKey('q', true); e.preventDefault(); });
    document.getElementById('btn-left').addEventListener('touchend', e => { setKey('q', false); e.preventDefault(); });
    document.getElementById('btn-right').addEventListener('touchstart', e => { setKey('d', true); e.preventDefault(); });
    document.getElementById('btn-right').addEventListener('touchend', e => { setKey('d', false); e.preventDefault(); });
    document.getElementById('btn-jump').addEventListener('touchstart', e => { setKey('z', true); e.preventDefault(); });
    document.getElementById('btn-jump').addEventListener('touchend', e => { setKey('z', false); e.preventDefault(); });
    // Affiche/masque les boutons selon la taille d'écran
    function updateTouchControls() {
        const controls = document.getElementById('touch-controls');
        if (window.innerWidth < 1000 || window.innerHeight < 800) controls.style.display = 'flex';
        else controls.style.display = 'none';
    }
    window.addEventListener('resize', updateTouchControls);
    updateTouchControls();
});
</script>
{% endblock %}
